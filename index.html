<!DOCTYPE html />

<html>
<head>
    <title>Frank.fs</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <link href="focco.css" rel="stylesheet" media="all" type="text/css" />
    <script src="prettify.js" type="text/javascript"></script>
</head>
<body onload="prettyPrint()">
    <div id="container">
        <div id="background"></div>
            <div id="jump_to">
                Jump To &hellip;
                <div id="jump_wrapper">
                    <div id="jump_page">
                        <a class="source" href="assemblyinfo.html">
                            AssemblyInfo.fs
                        </a>
                        <a class="source" href="index.html">
                            Frank.fs
                        </a>
                        <a class="source" href="hosting.html">
                            Hosting.fs
                        </a>
                        <a class="source" href="middleware.html">
                            Middleware.fs
                        </a>
                    </div>
                </div>
            </div>
        <table cellpadding="0" cellspacing="0">
            <thead>
                <tr>
                    <th class="docs">
                        <h1>Frank.fs</h1>
                    </th>
                    <th class="code"></th>
                </tr>
            </thead>
            <tbody>
                <tr id="section_1">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_1">&#182;</a>
                        </div>
                        <h1>Frank</h1>

<h2>License</h2>

<p>Author: Ryan Riley <a href="&#109;a&#105;&#108;&#x74;&#x6f;:&#x72;&#121;&#97;n&#46;&#x72;&#x69;&#x6c;&#101;&#x79;&#64;&#x70;&#97;&#110;&#101;&#115;&#111;f&#x67;&#x6c;&#97;&#115;&#115;&#x2e;&#x6f;r&#103;">&#x72;&#121;&#97;n&#46;&#x72;&#x69;&#x6c;&#101;&#x79;&#64;&#x70;&#97;&#110;&#101;&#115;&#111;f&#x67;&#x6c;&#97;&#115;&#115;&#x2e;&#x6f;r&#103;</a>
Copyright (c) 2011, Ryan Riley.</p>

<p>Licensed under the Apache License, Version 2.0.
See LICENSE.txt for details.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>[&lt;AutoOpen&gt;]
module Frank.Core

open System
open System.Collections.Generic
open System.IO
open System.Net
open System.Net.Http
open System.Net.Http.Formatting
open System.Net.Http.Headers
open System.Text
open FSharpx
open FSharpx.Reader
open FSharpx.Http

#if DEBUG
open System.Json
open ImpromptuInterface.FSharp
open NUnit.Framework
open Swensen.Unquote.Assertions
#endif

</code></pre>
                    </td>
                </tr>
                <tr id="section_2">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_2">&#182;</a>
                        </div>
                        <h2>Define the web application interface</h2>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
</code></pre>
                    </td>
                </tr>
                <tr id="section_3">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_3">&#182;</a>
                        </div>
                        <p>One may define a web application interface using a large variety of signatures.
Indeed, if you search the web, you're likely to find a large number of approaches.
When starting with <code>Frank</code>, I wanted to try to find a way to define an HTTP application
using pure functions and function composition. The closest I found was the following:</p>

<pre><code>type HttpRequestHandler = HttpContent -&gt; Async&lt;HttpResponseMessage&gt;
type HttpApplication = HttpRequestMessage -&gt; HttpRequestHandler

let orElse right left = fun request -&gt; Option.orElse (left request) (right request)
let inline (&lt;|&gt;) left right = orElse right left
</code></pre>

<p>The last of these was a means for merging multiple applications together into a single
application. This allowed for a nice symmetry and elegance in that everything you composed
would always have the same signature. Additional functions would allow you to map
applications to specific methods or uri patterns.</p>

<p>Alas, this approach works only so well. HTTP is a rich communication specification.
The simplicity and elegance of a purely functional approach quickly loses the ability
to communicate back options to the client. For instance, given the above, how do you
return a meaningful <code>405 Method Not Allowed</code> response? The HTTP specification requires
that you list the allowed methods, but if you merge all the logic for selecting an
application into the functions, there is no easy way to recall all the allowed methods,
short of trying them all. You could require that the developer add the list of used
methods, but that, too, misses the point that the application should be collecting this
and helping the developer by taking care of all of the nuts and bolts items</p>

<p>The next approach I tried involved using a tuple of a list of allowed HTTP methods and
the application handler, which used the merged function approach described above for
actually executing the application. However, once again, there are limitations. This
structure accurately represents a resource, but it does not allow for multiple resources
to coexist side-by-side. Another tuple of uri pattern matching expressions could wrap
a list of these method * handler tuples, but at this point I realized I would be better
served by using real types and thus arrived at the signatures below.</p>

<p>You'll see the signatures above are still mostly present, though they have been changed
to better fit the signatures below.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
</code></pre>
                    </td>
                </tr>
                <tr id="section_4">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_4">&#182;</a>
                        </div>
                        <p>An <code>HttpRequestHandler</code> takes an <code>HttpContent</code>, or request body, and returns the
appropriate <code>HttpResponseMessage</code>. This handler is returned by an <code>HttpApplication</code>.
Why the split? Splitting the acceptance of the request headers from the actual
request body allows you to decide what you want to do earlier. Thus, should you
receive a request header specifying a specific <code>Accept</code>-ed content type, you can
select an appropriate handler that returns that type. It also allows you to return
a 404, 405, or other message before reading the content, should you determine that
the request is invalid based on its headers.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>type HttpRequestHandler = HttpContent -&gt; Async&lt;HttpResponseMessage&gt;

</code></pre>
                    </td>
                </tr>
                <tr id="section_5">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_5">&#182;</a>
                        </div>
                        <p><code>HttpApplication</code> defines the contract for processing any request.
An application takes an <code>HttpRequestMessage</code> and returns an <code>HttpRequestHandler</code>.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>type HttpApplication = HttpRequestMessage -&gt; HttpRequestHandler

</code></pre>
                    </td>
                </tr>
                <tr id="section_6">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_6">&#182;</a>
                        </div>
                        <h2>Helper Types</h2>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
type EmptyContent() =
  inherit HttpContent()
  override x.SerializeToStreamAsync(stream, context) =
    new System.Threading.Tasks.Task(fun () -&gt; ())
  override x.TryComputeLength(length) =
    length &lt;- 0L
    true
  override x.Equals(other) =
    other.GetType() = typeof&lt;EmptyContent&gt;
  override x.GetHashCode() = hash x

type HttpContent with
  static member Empty = new EmptyContent() :&gt; HttpContent
  member x.AsyncReadAs&lt;&#39;a&gt;() = Async.AwaitTask &lt;| x.ReadAsAsync&lt;&#39;a&gt;()
  member x.AsyncReadAs&lt;&#39;a&gt;(formatters) = Async.AwaitTask &lt;| x.ReadAsAsync&lt;&#39;a&gt;(formatters)
  member x.AsyncReadAs(type&#39;) = Async.AwaitTask &lt;| x.ReadAsAsync(type&#39;)
  member x.AsyncReadAs(type&#39;, formatters) = Async.AwaitTask &lt;| x.ReadAsAsync(type&#39;, formatters)
  member x.AsyncReadAsByteArray() = Async.AwaitTask &lt;| x.ReadAsByteArrayAsync()
  member x.AsyncReadAsMultipart() = Async.AwaitTask &lt;| x.ReadAsMultipartAsync()
  member x.AsyncReadAsMultipart(streamProvider) = Async.AwaitTask &lt;| x.ReadAsMultipartAsync(streamProvider)
  member x.AsyncReadAsMultipart(streamProvider, bufferSize) = Async.AwaitTask &lt;| x.ReadAsMultipartAsync(streamProvider, bufferSize)
  member x.AsyncReadAsOrDefault&lt;&#39;a&gt;() = Async.AwaitTask &lt;| x.ReadAsOrDefaultAsync&lt;&#39;a&gt;()
  member x.AsyncReadAsOrDefault&lt;&#39;a&gt;(formatters) = Async.AwaitTask &lt;| x.ReadAsOrDefaultAsync&lt;&#39;a&gt;(formatters)
  member x.AsyncReadAsOrDefault(type&#39;) = Async.AwaitTask &lt;| x.ReadAsOrDefaultAsync(type&#39;)
  member x.AsyncReadAsOrDefault(type&#39;, formatters) = Async.AwaitTask &lt;| x.ReadAsOrDefaultAsync(type&#39;, formatters)
  member x.AsyncReadAsStream() = Async.AwaitTask &lt;| x.ReadAsStreamAsync()
  member x.AsyncReadAsString() = Async.AwaitTask &lt;| x.ReadAsStringAsync()

</code></pre>
                    </td>
                </tr>
                <tr id="section_7">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_7">&#182;</a>
                        </div>
                        <h2>HTTP Response Combinators</h2>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
</code></pre>
                    </td>
                </tr>
                <tr id="section_8">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_8">&#182;</a>
                        </div>
                        <p>Headers are added using the <code>Reader</code> monad. If F# allows mutation, why do we need the monad?
First of all, it allows for the explicit declaration of side effects. Second, a number
of combinators are already defined that allows you to more easily compose headers.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>type HttpResponseHeadersBuilder = Reader&lt;HttpResponseMessage, unit&gt;
let headers = Reader.reader
let addHeaders (headers: HttpResponseHeadersBuilder) response = headers response; response

type HttpResponseBody =
  | Empty
  | Stream of System.IO.Stream
  | Bytes of byte[]
  | Str of string

</code></pre>
                    </td>
                </tr>
                <tr id="section_9">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_9">&#182;</a>
                        </div>
                        <p>Convert an optional response body argument into an actual <code>HttpContent</code> type.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let inline makeHttpContent body =
  match body with
  | Empty -&gt; HttpContent.Empty
  | Stream v -&gt; new StreamContent(v) :&gt; HttpContent
  | Bytes v -&gt; new ByteArrayContent(v) :&gt; HttpContent
  | Str v -&gt; new StringContent(v) :&gt; HttpContent

</code></pre>
                    </td>
                </tr>
                <tr id="section_10">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_10">&#182;</a>
                        </div>
                        <p>Responding with the actual types can get a bit noisy with the long type names and required
type cast to <code>HttpResponseMessage</code> (since most responses will include a typed body).
The <code>respond</code> function simplifies this and also accepts an <code>HttpResponseHeadersBuilder</code>
to allow easy composition and inclusion of headers. This function finally takes an optional
<code>body</code>.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let respond (statusCode: HttpStatusCode) (headers: HttpResponseHeadersBuilder) body =
  new HttpResponseMessage(statusCode, Content = makeHttpContent body)
  |&gt; addHeaders headers
  |&gt; async.Return

#if DEBUG
[&lt;Test&gt;]
let ``test respond without body``() =
  let statusCode = HttpStatusCode.OK
  let response = respond statusCode ignore Empty |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = statusCode @&gt;
  test &lt;@ response.Content = HttpContent.Empty @&gt;

[&lt;Test&gt;]
let ``test respond with body``() =
  let statusCode, body = HttpStatusCode.OK, &quot;Howdy&quot;
  let response = respond statusCode ignore &lt;| Str body |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = statusCode @&gt;
  test &lt;@ response.Content.ReadAsStringAsync().Result = body @&gt;
#endif

</code></pre>
                    </td>
                </tr>
                <tr id="section_11">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_11">&#182;</a>
                        </div>
                        <h3>General Headers</h3>

<p>TODO: Rely less upon the <code>Parse</code> and <code>ParseAdd</code> methods and pass in more of the parameters.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let Date x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Date &lt;- Nullable.create x

let Connection x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Connection.ParseAdd x

let Trailer x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Trailer.ParseAdd x

let ``Transfer-Encoding`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.TransferEncoding.ParseAdd x

let Upgrade x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Upgrade.ParseAdd x

let Via x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Via.ParseAdd x

let ``Cache-Control`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.CacheControl &lt;- CacheControlHeaderValue.Parse x

let Pragma x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Pragma.ParseAdd x

</code></pre>
                    </td>
                </tr>
                <tr id="section_12">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_12">&#182;</a>
                        </div>
                        <h3>Response Headers</h3>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let Age x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Age &lt;- Nullable.create x

let ``Retry-After`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.RetryAfter &lt;- RetryConditionHeaderValue.Parse x

let Server x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Server.ParseAdd x

let Warning x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Warning.ParseAdd x

let ``Accept-Ranges`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.AcceptRanges.ParseAdd x

let Vary x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Vary.ParseAdd x

let ``Proxy-Authenticate`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.ProxyAuthenticate.ParseAdd x

let ``WWW-Authenticate`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.WwwAuthenticate.ParseAdd x

</code></pre>
                    </td>
                </tr>
                <tr id="section_13">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_13">&#182;</a>
                        </div>
                        <h3>Entity Headers</h3>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let Allow x : HttpResponseHeadersBuilder =
  fun response -&gt; Seq.iter response.Content.Headers.Allow.Add x

let Location x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.Location &lt;- x

let ``Content-Disposition`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Content.Headers.ContentDisposition &lt;- ContentDispositionHeaderValue x

let ``Content-Encoding`` x : HttpResponseHeadersBuilder =
  fun response -&gt; Seq.iter response.Content.Headers.ContentEncoding.Add x

let ``Content-Language`` x : HttpResponseHeadersBuilder =
  fun response -&gt; Seq.iter response.Content.Headers.ContentLanguage.Add x 

let ``Content-Length`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Content.Headers.ContentLength &lt;- Nullable.create x

let ``Content-Location`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Content.Headers.ContentLocation &lt;- x

let ``Content-MD5`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Content.Headers.ContentMD5 &lt;- x

let ``Content-Range`` from _to length : HttpResponseHeadersBuilder =
  fun response -&gt; response.Content.Headers.ContentRange &lt;- ContentRangeHeaderValue(from, _to, length)

let ``Content-Type`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Content.Headers.ContentType &lt;- MediaTypeHeaderValue x

let ETag tag isWeak : HttpResponseHeadersBuilder =
  fun response -&gt; response.Headers.ETag &lt;- EntityTagHeaderValue(tag, isWeak)

let Expires x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Content.Headers.Expires &lt;- Nullable.create x

let ``Last Modified`` x : HttpResponseHeadersBuilder =
  fun response -&gt; response.Content.Headers.LastModified &lt;- Nullable.create x

</code></pre>
                    </td>
                </tr>
                <tr id="section_14">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_14">&#182;</a>
                        </div>
                        <h3>Allow Header Helpers</h3>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
</code></pre>
                    </td>
                </tr>
                <tr id="section_15">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_15">&#182;</a>
                        </div>
                        <p>A few responses should return allowed methods (<code>OPTIONS</code> and <code>405 Method Not Allowed</code>).
<code>respondWithAllowHeader</code> allows both methods to share common functionality.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let private respondWithAllowHeader statusCode (allowedMethods: #seq&lt;string&gt;) body =
  fun _ _ -&gt;
    respond statusCode (Allow allowedMethods) body

</code></pre>
                    </td>
                </tr>
                <tr id="section_16">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_16">&#182;</a>
                        </div>
                        <p><code>OPTIONS</code> responses should return the allowed methods, and this helper facilitates method calls.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let options allowedMethods =
  respondWithAllowHeader HttpStatusCode.OK allowedMethods Empty

#if DEBUG
[&lt;Test&gt;]
let ``test options``() =
  let response = options [&quot;GET&quot;;&quot;POST&quot;] (obj()) (obj()) |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = HttpStatusCode.OK @&gt;
  test &lt;@ response.Content.Headers.Allow.Contains(&quot;GET&quot;) @&gt;
  test &lt;@ response.Content.Headers.Allow.Contains(&quot;POST&quot;) @&gt;
  test &lt;@ not &lt;| response.Content.Headers.Allow.Contains(&quot;PUT&quot;) @&gt;
  test &lt;@ not &lt;| response.Content.Headers.Allow.Contains(&quot;DELETE&quot;) @&gt;
#endif

</code></pre>
                    </td>
                </tr>
                <tr id="section_17">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_17">&#182;</a>
                        </div>
                        <p>In some instances, you need to respond with a <code>405 Message Not Allowed</code> response.
The HTTP spec requires that this message include an <code>Allow</code> header with the allowed
HTTP methods.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let ``405 Method Not Allowed`` allowedMethods =
  respondWithAllowHeader HttpStatusCode.MethodNotAllowed allowedMethods &lt;| Str &quot;405 Method Not Allowed&quot;

#if DEBUG
[&lt;Test&gt;]
let ``test 405 Method Not Allowed``() =
  let response = ``405 Method Not Allowed`` [&quot;GET&quot;;&quot;POST&quot;] (obj()) (obj()) |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = HttpStatusCode.MethodNotAllowed @&gt;
  test &lt;@ response.Content.Headers.Allow.Contains(&quot;GET&quot;) @&gt;
  test &lt;@ response.Content.Headers.Allow.Contains(&quot;POST&quot;) @&gt;
  test &lt;@ not &lt;| response.Content.Headers.Allow.Contains(&quot;PUT&quot;) @&gt;
  test &lt;@ not &lt;| response.Content.Headers.Allow.Contains(&quot;DELETE&quot;) @&gt;
#endif

</code></pre>
                    </td>
                </tr>
                <tr id="section_18">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_18">&#182;</a>
                        </div>
                        <h2>Content Negotiation Helpers</h2>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
let ``406 Not Acceptable`` =
  fun _ _ -&gt;
    respond HttpStatusCode.NotAcceptable ignore &lt;| Str &quot;406 Not Acceptable&quot;

#if DEBUG
[&lt;Test&gt;]
let ``test 406 Not Acceptable``() =
  let response = ``406 Not Acceptable`` (obj()) (obj()) |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = HttpStatusCode.NotAcceptable @&gt;
#endif

let findFormatterFor mediaType =
  Seq.find (fun (formatter: MediaTypeFormatter) -&gt;
    formatter.SupportedMediaTypes
    |&gt; Seq.map (fun value -&gt; value.MediaType)
    |&gt; Seq.exists ((=) mediaType))

</code></pre>
                    </td>
                </tr>
                <tr id="section_19">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_19">&#182;</a>
                        </div>
                        <p><code>readRequestBody</code> takes a collection of <code>HttpContent</code> formatters and returns a typed result from reading the content.
This is useful if you have several options for receiving data such as JSON, XML, or form-urlencoded and want to produce
a similar type against which to calculate a response.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let readRequestBody formatters (content: HttpContent) = content.AsyncReadAsStream()

let internal accepted (request: HttpRequestMessage) = request.Headers.Accept.ToString()

</code></pre>
                    </td>
                </tr>
                <tr id="section_20">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_20">&#182;</a>
                        </div>
                        <p><code>formatWith</code> allows you to specify a specific <code>formatter</code> with which to render a representation
of your content body.</p>

<p>The <code>Web API</code> tries to do this for you at this time, so this function is likely to be clobbered,
or rather, wrapped again in another representation. Hopefully, this will get fixed in a future release.</p>

<p>Further note that the current solution requires creation of <code>ObjectContent&lt;_&gt;</code>, which is certainly
not optimal. Hopefully this, too, will be resolved in a future release.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let formatWith (mediaType: string) formatter body = async {
  let content = new ObjectContent&lt;_&gt;(body, mediaType, [| formatter |]) :&gt; HttpContent
  let! formattedBody = content.AsyncReadAsStream()
  return formattedBody }

#if DEBUG
type TestType = { FirstName : string; LastName : string }

[&lt;Test&gt;]
let ``test formatWith and makeHttpContent properly format as application/json``() =
  let formatter = new System.Net.Http.Formatting.JsonMediaTypeFormatter()
  let body = { FirstName = &quot;Ryan&quot;; LastName = &quot;Riley&quot; }
  let formattedBody = body |&gt; formatWith &quot;application/json&quot; formatter |&gt; Async.RunSynchronously
  let content = makeHttpContent &lt;| Stream formattedBody
  let result = content.ReadAsStringAsync().Result
  test &lt;@ result = &quot;{\&quot;FirstName@\&quot;:\&quot;Ryan\&quot;,\&quot;LastName@\&quot;:\&quot;Riley\&quot;}&quot; @&gt;
#endif

</code></pre>
                    </td>
                </tr>
                <tr id="section_21">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_21">&#182;</a>
                        </div>
                        <p>When you want to negotiate the format of the response based on the available representations and
the <code>request</code>'s <code>Accept</code> headers, you can <code>tryNegotiateMediaType</code>. This takes a set of available
<code>formatters</code> and attempts to match the best with the provided <code>Accept</code> header values using
functions from <code>FSharpx.Http</code>.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let negotiateMediaType formatters f =
  let servedMedia =
    formatters
    |&gt; Seq.collect (fun (formatter: MediaTypeFormatter) -&gt; formatter.SupportedMediaTypes)
    |&gt; Seq.map (fun value -&gt; value.MediaType)
  let bestOf = accepted &gt;&gt; FsConneg.bestMediaType servedMedia &gt;&gt; Option.map fst
  fun request -&gt;
    match bestOf request with
    | Some mediaType -&gt;
        let formatter = findFormatterFor mediaType formatters
        fun content -&gt; async {
          let! responseBody = f request content
          let! formattedBody = responseBody |&gt; formatWith mediaType formatter
          return! respond HttpStatusCode.OK (``Content-Type`` mediaType *&gt; ``Vary`` &quot;Accept&quot;) &lt;| Stream formattedBody }
    | _ -&gt; ``406 Not Acceptable`` request

</code></pre>
                    </td>
                </tr>
                <tr id="section_22">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_22">&#182;</a>
                        </div>
                        <p>The most direct way of building an HTTP application is to focus on the actual types
being transacted. These usually come in the form of the content of the request and response
message bodies. The <code>f</code> function accepts the <code>request</code> and the deserialized <code>content</code>.
The <code>request</code> is provided to allow the function access to the request headers, which also
allows us to merge several handler functions and select the appropriate handler using
request header data.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let mapWithConneg formatters f =
  negotiateMediaType formatters
  &lt;| fun request content -&gt; async {
      let! requestBody = readRequestBody formatters content
      return f request requestBody }

</code></pre>
                    </td>
                </tr>
                <tr id="section_23">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_23">&#182;</a>
                        </div>
                        <h2>HTTP Resources</h2>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
</code></pre>
                    </td>
                </tr>
                <tr id="section_24">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_24">&#182;</a>
                        </div>
                        <p>HTTP resources expose an resource handler function at a given uri.
In the common MVC-style frameworks, this would roughly correspond
to a <code>Controller</code>. Resources should represent a single entity type,
and it is important to note that a <code>Foo</code> is not the same entity
type as a <code>Foo list</code>, which is where most MVC approaches go wrong. </p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>type HttpResource =
  { Uri: string
    Methods: string list
    Handler: HttpRequestMessage -&gt; HttpRequestHandler option }
  with

</code></pre>
                    </td>
                </tr>
                <tr id="section_25">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_25">&#182;</a>
                        </div>
                        <p>TODO: add a method to match the Uri.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
</code></pre>
                    </td>
                </tr>
                <tr id="section_26">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_26">&#182;</a>
                        </div>
                        <p>With the <code>405 Method Not Allowed</code> function, resources can correctly respond to messages.
Therefore, we'll extend the <code>HttpResource</code> with an <code>Invoke</code> method. Without the <code>Invoke</code> method,
the <code>HttpResource</code> is left without any true representation of an <code>HttpApplication</code>.</p>

<p>Also note that the methods will always be looked up using the latest set. This could
probably be memoized so as to save a bit of time, but it allows us to ensure that all
available methods are reported.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>  member x.Invoke(request) =
    match x.Handler request with
    | Some h -&gt; h
    | _ -&gt; ``405 Method Not Allowed`` x.Methods request

let private makeHandler(httpMethod, handler) =
  function (request: HttpRequestMessage) when request.Method.Method = httpMethod -&gt; Some(handler request)
         | _ -&gt; None

</code></pre>
                    </td>
                </tr>
                <tr id="section_27">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_27">&#182;</a>
                        </div>
                        <p>Helpers to more easily map <code>HttpApplication</code> functions to methods to be composed into <code>HttpResource</code>s.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let mapResourceHandler(httpMethod, handler) = [httpMethod], makeHandler(httpMethod, handler)
let get handler = mapResourceHandler(HttpMethod.Get.Method, handler)
let post handler = mapResourceHandler(HttpMethod.Post.Method, handler)
let put handler = mapResourceHandler(HttpMethod.Put.Method, handler)
let delete handler = mapResourceHandler(HttpMethod.Delete.Method, handler)

</code></pre>
                    </td>
                </tr>
                <tr id="section_28">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_28">&#182;</a>
                        </div>
                        <p>We can use several methods to merge multiple handlers together into a single resource.
Our chosen mechanism here is merging functions into a larger function of the same signature.
This allows us to create resources as follows:</p>

<pre><code>let resource = get app1 &lt;|&gt; post app2 &lt;|&gt; put app3 &lt;|&gt; delete app4
</code></pre>

<p>The intent here is to build a resource, with at most one handler per HTTP method. This goes
against a lot of the "RESTful" approaches that just merge a bunch of method handlers at
different URI addresses.</p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>let orElse right left =
  fst left @ fst right,
  fun request -&gt; Option.orElse (snd left request) (snd right request)
let inline (&lt;|&gt;) left right = left |&gt; orElse right

let route path handler =
  { Uri = path
    Methods = fst handler
    Handler = snd handler }

let routeWithMethodMapping path handlers = route path &lt;| Seq.reduce orElse handlers

</code></pre>
                    </td>
                </tr>
                <tr id="section_29">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_29">&#182;</a>
                        </div>
                        <h2>HTTP Applications</h2>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'>
let ``404 Not Found`` : HttpApplication =
  fun _ _ -&gt; respond HttpStatusCode.NotFound ignore &lt;| Str &quot;404 Not Found&quot;

let findApplicationFor resources (request: HttpRequestMessage) =
  let resource = Seq.tryFind (fun r -&gt; r.Uri = request.RequestUri.AbsolutePath) resources
  let handler = resource |&gt; Option.map (fun r -&gt; r.Invoke)
  handler

#if DEBUG
let stub _ _ = respond HttpStatusCode.OK ignore Empty
let resource1 = route &quot;/&quot; (get stub &lt;|&gt; post stub)
let resource2 = route &quot;/stub&quot; &lt;| get stub

[&lt;Test&gt;]
let ``test should find nothing at GET /baduri``() =
  let request = new HttpRequestMessage(HttpMethod.Get, new Uri(&quot;http://example.org/baduri&quot;))
  let handler = findApplicationFor [resource1; resource2] request
  test &lt;@ handler.IsNone @&gt;

[&lt;Test&gt;]
let ``test should find stub at GET /``() =
  let request = new HttpRequestMessage(HttpMethod.Get, new Uri(&quot;http://example.org/&quot;))
  let handler = findApplicationFor [resource1; resource2] request
  test &lt;@ handler.IsSome @&gt;

[&lt;Test&gt;]
let ``test should find stub at POST /``() =
  let request = new HttpRequestMessage(HttpMethod.Post, new Uri(&quot;http://example.org/&quot;)) 
  let handler = findApplicationFor [resource1; resource2] request
  test &lt;@ handler.IsSome @&gt;

[&lt;Test&gt;]
let ``test should find stub at GET /stub``() =
  let request = new HttpRequestMessage(HttpMethod.Post, new Uri(&quot;http://example.org/&quot;))
  let handler = findApplicationFor [resource1; resource2] request
  test &lt;@ handler.IsSome @&gt;
#endif

let mergeWithNotFound notFoundHandler (resources: #seq&lt;HttpResource&gt;) : HttpApplication =
  fun request -&gt;
    let handler = findApplicationFor resources request |&gt; (flip defaultArg) notFoundHandler
    fun content -&gt; async {
      let! response = handler request content
      return response }

let merge resources = mergeWithNotFound ``404 Not Found`` resources

#if DEBUG
[&lt;Test&gt;]
let ``test should return 404 Not Found as the handler``() =
  let app = merge []
  let request = new HttpRequestMessage()
  let response = app request HttpContent.Empty |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = HttpStatusCode.NotFound @&gt;

[&lt;Test&gt;]
let ``test should return 404 Not Found as the handler when other resources are available``() =
  let app = merge [resource1; resource2]
  let request = new HttpRequestMessage(HttpMethod.Get, new Uri(&quot;http://example.org/baduri&quot;))
  let response = app request HttpContent.Empty |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = HttpStatusCode.NotFound @&gt;

[&lt;Test&gt;]
let ``test should return stub at GET /``() =
  let app = merge [resource1; resource2]
  let request = new HttpRequestMessage(HttpMethod.Get, new Uri(&quot;http://example.org/&quot;))
  let response = app request HttpContent.Empty |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = HttpStatusCode.OK @&gt;

[&lt;Test&gt;]
let ``test should return stub at POST /``() =
  let app = merge [resource1; resource2]
  let request = new HttpRequestMessage(HttpMethod.Post, new Uri(&quot;http://example.org/&quot;)) 
  let response = app request HttpContent.Empty |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = HttpStatusCode.OK @&gt;

[&lt;Test&gt;]
let ``test should return stub at GET /stub``() =
  let app = merge [resource1; resource2]
  let request = new HttpRequestMessage(HttpMethod.Get, new Uri(&quot;http://example.org/stub&quot;))
  let response = app request HttpContent.Empty |&gt; Async.RunSynchronously
  test &lt;@ response.StatusCode = HttpStatusCode.OK @&gt;
#endif

let private startAsTask (app: HttpApplication) (request, cancelationToken) =
  Async.StartAsTask(app request request.Content, cancellationToken = cancelationToken)

type FrankHandler() =
  inherit DelegatingHandler()
  static member Create(app) =
    let app = startAsTask app
    { new FrankHandler() with
        override this.SendAsync(request, cancelationToken) =
          app(request, cancelationToken) } :&gt; DelegatingHandler

</code></pre>
                    </td>
                </tr>
                <tr id="section_30">
                    <td class="docs">
                        <div class="pilwrap">
                            <a class="pilcrow" href="#section_30">&#182;</a>
                        </div>
                        <p>let formatter = FormUrlEncodedMediaTypeFormatter() :> Formatting.MediaTypeFormatter
let testBody = dict [("foo", "bar");("bar", "baz")]
let createTestRequest() =
 new HttpRequestMessage(
   HttpMethod.Post, Uri("http://frankfs.net/"),
   Version = Version(1,1),
   Content = new FormUrlEncodedContent(testBody))</p>

<p>let echo (request : HttpRequestMessage) = 
 let body = request.Content.ReadAs<JsonValue>(seq { yield formatter })
 let response = new HttpResponseMessage<JsonValue>(body, HttpStatusCode.OK)
 response.Content.Headers.ContentType &lt;- Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded")
 response</p>

<p>[<Test>]
let <code>test echo should return a response of 200 OK</code>() =
 let actual = echo &lt;| createTestRequest()
 test &lt;@ actual.StatusCode = HttpStatusCode.OK @></p>

<p>[<Test>]
let <code>test echo should return a response with one header for Content_Type of application/x-www-form-urlencoded</code>() =
 let expected = Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded")
 let actual = echo &lt;| createTestRequest()
 test &lt;@ actual.Content.Headers.ContentType = expected @></p>

<p>[<Test>]
let <code>test echo should return a response with a body of echoing the request body</code>() =
 let response = echo &lt;| createTestRequest()
 let actual = response.Content.ReadAs()
 test &lt;@ actual?foo = "bar" @>
 test &lt;@ actual?bar = "baz" @></p>

<p>let formatter = FormUrlEncodedMediaTypeFormatter() :> Formatting.MediaTypeFormatter
let testBody = dict [("foo", "bar");("bar", "baz")]
let createTestRequest() =
 new HttpRequestMessage(
   HttpMethod.Post, Uri("http://frankfs.net/"),
   Version = Version(1,1),
   Content = new FormUrlEncodedContent(testBody))</p>

<p>let echo (request : HttpRequestMessage) = 
 let body = request.Content.ReadAs<JsonValue>(seq { yield formatter })
 let response = new HttpResponseMessage<JsonValue>(body, HttpStatusCode.OK)
 response.Content.Headers.ContentType &lt;- Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded")
 response</p>

<p>[<Test>]
let <code>test echo should return a response of 200 OK</code>() =
 let actual = echo &lt;| createTestRequest()
 test &lt;@ actual.StatusCode = HttpStatusCode.OK @></p>

<p>[<Test>]
let <code>test echo should return a response with one header for Content_Type of application/x-www-form-urlencoded</code>() =
 let expected = Headers.MediaTypeHeaderValue.Parse("application/x-www-form-urlencoded")
 let actual = echo &lt;| createTestRequest()
 test &lt;@ actual.Content.Headers.ContentType = expected @></p>

<p>[<Test>]
let <code>test echo should return a response with a body of echoing the request body</code>() =
 let response = echo &lt;| createTestRequest()
 let actual = response.Content.ReadAs()
 test &lt;@ actual?foo = "bar" @>
 test &lt;@ actual?bar = "baz" @></p>

                    </td>
                    <td class="code">
                        <pre><code class='prettyprint'></code></pre>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
</html>
